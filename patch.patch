diff --git a/ios/Handlers/AllTouchesGestureRecognizer.swift b/ios/Handlers/AllTouchesGestureRecognizer.swift
new file mode 100644
index 0000000..eac44d5
--- /dev/null
+++ b/ios/Handlers/AllTouchesGestureRecognizer.swift
@@ -0,0 +1,390 @@
+import Foundation
+import UIKit
+
+/** A 2D vector composed of `CGFloat`s. */
+public protocol CGVector2 {
+    init(x: CGFloat, y: CGFloat)
+    var x: CGFloat { get set }
+    var y: CGFloat { get set }
+}
+
+// DL: some of these methods are not necessary for this project - I pulled some
+// of this code from a personal codebase, and I'm not taking the time to look
+// through what is / is not used.
+extension CGVector2 {
+    init<V: CGVector2>(_ otherVec2: V) {
+        self.init(x: otherVec2.x, y: otherVec2.y)
+    }
+    
+    static func unit(_ n: CGFloat = 1) -> Self {
+        Self(x: n, y: n)
+    }
+    
+    var reciprocal: Self {
+        Self.unit(1) / self
+    }
+    
+    var magnitude: CGFloat {
+        return (x * x + y * y).squareRoot()
+    }
+    
+    func zip<V: CGVector2>(_ rhs: V, with zipper: (CGFloat, CGFloat) -> CGFloat) -> Self {
+        return Self(x: zipper(self.x, rhs.x), y: zipper(self.y, rhs.y))
+    }
+    
+    func map(_ transform: (CGFloat) -> CGFloat) -> Self {
+        return Self(x: transform(x), y: transform(y))
+    }
+    
+    func map<T>(_ transform: (CGFloat) -> T) -> (x: T, y: T) {
+        return (x: transform(x), y: transform(y))
+    }
+    
+    static func -<V: CGVector2>(lhs: Self, rhs: V) -> Self {
+        return lhs.zip(rhs, with: (-))
+    }
+    
+    static prefix func -(operand: Self) -> Self {
+        operand.negated
+    }
+    
+    var negated: Self {
+        map { -$0 }
+    }
+    
+    static func +<V: CGVector2>(lhs: Self, rhs: V) -> Self {
+        lhs.zip(rhs, with: (+))
+    }
+    
+    static func +=<V: CGVector2>(lhs: inout Self, rhs: V) {
+        lhs.x += rhs.x
+        lhs.y += rhs.y
+    }
+    
+    static func *(scalar: CGFloat, v: Self) -> Self {
+        return v.map { $0 * scalar }
+    }
+    
+    static func *(v: Self, scalar: CGFloat) -> Self {
+        return scalar * v
+    }
+    
+    static func *<V: CGVector2>(rhs: Self, lhs: V) -> Self {
+        rhs.zip(lhs, with: (*))
+    }
+    
+    static func /<V: CGVector2>(l: Self, r: V) -> Self {
+        return Self(x: l.x / r.x, y: l.y / r.y)
+    }
+    
+    var floored: Self {
+        Self(x: floor(x), y: floor(y))
+    }
+    
+    var rounded: Self {
+        Self(x: floor(x + 0.5), y: floor(y + 0.5))
+    }
+    
+    func distance<V: CGVector2>(to other: V) -> CGFloat {
+        return (other - self).magnitude
+    }
+    
+    var direction: CGFloat {
+        var out = atan2(y, x)
+        if out < 0 {
+            out += 2 * .pi
+        }
+        return out
+    }
+}
+
+// Adopt `CGVector2` on CGPoint / CGSize.
+extension CGPoint: CGVector2 {}
+extension CGPoint: ExpressibleByArrayLiteral {}
+extension CGSize: CGVector2 {
+    public init(x: CGFloat, y: CGFloat) {
+        self.init(width: x, height: y)
+    }
+    
+    public var x: CGFloat {
+        get { width }
+        set { width = newValue }
+    }
+    public var y: CGFloat {
+        get { height }
+        set { height = newValue }
+    }
+}
+extension CGSize: ExpressibleByArrayLiteral {}
+
+extension CGVector2 where Self: ExpressibleByArrayLiteral {
+    public init(arrayLiteral elements: CGFloat...) {
+        assert(elements.count == 2, "Expected array literal with 2 elements")
+        self.init(x: elements[0], y: elements[1])
+    }
+}
+
+/** Gesture recognizer tracking all touch locations. */
+public class TraceGestureRecognizer: UIGestureRecognizer {
+    struct TouchSample {
+        let location: CGPoint
+        let touch: UITouch
+        
+        static func from(_ touch: UITouch, transform: CGAffineTransform, locationReference: UIView?) -> TouchSample {
+            TouchSample(
+                location: touch.location(in: locationReference).applying(transform),
+                touch: touch
+            )
+        }
+    }
+    
+    var samples: Set<TouchSample> = []
+    var transform: CGAffineTransform = .identity
+    
+    func didUpdateSamples(previousSamples: Set<TouchSample>, with event: UIEvent) {}
+    
+    public override func reset() {
+        super.reset()
+        samples = []
+    }
+    
+    public override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent) {
+        super.touchesBegan(touches, with: event)
+        let previousSamples = samples
+        samples.formUnion(Set(touches.map { TouchSample.from($0, transform: transform, locationReference: self.view) }))
+        if samples.count == 1 {
+            state = .began
+        } else {
+            state = .changed
+        }
+        didUpdateSamples(previousSamples: previousSamples, with: event)
+    }
+    
+    public override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent) {
+        super.touchesMoved(touches, with: event)
+        let previousSamples = samples
+        samples = Set(samples.map { sample -> TouchSample in
+            guard touches.contains(sample.touch) else {
+                return sample
+            }
+            return TouchSample.from(sample.touch, transform: transform, locationReference: self.view)
+        })
+        state = .changed
+        didUpdateSamples(previousSamples: previousSamples, with: event)
+    }
+    
+    public override func touchesCancelled(_ touches: Set<UITouch>, with event: UIEvent) {
+        super.touchesCancelled(touches, with: event)
+        let previousSamples = samples
+        samples = samples.filter { $0.touch.phase != .cancelled }
+        if samples.count == 0 {
+            state = .ended
+        } else {
+            state = .changed
+        }
+        didUpdateSamples(previousSamples: previousSamples, with: event)
+    }
+    
+    public override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent) {
+        super.touchesEnded(touches, with: event)
+        let previousSamples = samples
+        samples = samples.filter { $0.touch.phase != .ended }
+        if samples.count == 0 {
+            state = .ended
+        } else {
+            state = .changed
+        }
+        didUpdateSamples(previousSamples: previousSamples, with: event)
+    }
+}
+
+extension TraceGestureRecognizer.TouchSample: Equatable {}
+extension TraceGestureRecognizer.TouchSample: Hashable {
+    func hash(into hasher: inout Hasher) {
+        hasher.combine(touch)
+        hasher.combine(location.x)
+        hasher.combine(location.y)
+    }
+}
+
+
+/** Gesture recognizer that provides a `transformFromLastChange` which
+ represents an incremental change in a transform controlled by 1-2 finger
+ gestures, like Google Maps. */
+@objc public class NaturalTransformGestureRecognizer: TraceGestureRecognizer {
+    var previousSamples: Set<TraceGestureRecognizer.TouchSample> = []
+    
+    /** Transform applied to touch locations before calculating a transform from
+     the touches. This is usually the current effective transform of the object
+     being transformed. */
+    var preTransformCalculationTransform: CGAffineTransform = .identity
+    
+    /** An incremental transform representing the change between the previous
+     two gesture changes (precisely, the change between the last two invocations
+     of `didUpdateSamples(previousSamples:, with:)`). */
+    @objc public var transformFromLastChange: CGAffineTransform {
+        guard previousSamples.count > 0 && samples.count > 0 else {
+            return .identity
+        }
+        
+        // `joined(with:, on:)` will quietly drop touches that were added or
+        // removed in this frame - i.e. the calculated transform will ignore
+        // those touches.
+        let samplesByTouch = previousSamples.joined(with: samples, on: { $0.touch })
+        
+        switch samplesByTouch.count {
+            case 1:
+                // simple translation - just find the offset
+                let (previousSample, sample) = samplesByTouch.values.first!
+                let translation = sample.location.applying(preTransformCalculationTransform) - previousSample.location.applying(preTransformCalculationTransform)
+                return CGAffineTransform(translationX: translation.x, y: translation.y)
+                
+            case 2:
+                // two-finger gesture -> two-finger gesture: find transform
+                // fitting these segments.
+                let vals = Array(samplesByTouch.values)
+                let (previousSampleA, sampleA) = vals[0]
+                let (previousSampleB, sampleB) = vals[1]
+                
+                return transformFromPinch(
+                    startingFrom: (
+                        previousSampleA.location.applying(preTransformCalculationTransform),
+                        previousSampleB.location.applying(preTransformCalculationTransform)
+                    ),
+                    endingAt: (
+                        sampleA.location.applying(preTransformCalculationTransform),
+                        sampleB.location.applying(preTransformCalculationTransform)
+                    )
+                )
+                
+            default:
+                // for everything else, don't effect a change (e.g. gestures
+                // with more than 2 fingers)
+                return .identity
+        }
+    }
+    
+    override func didUpdateSamples(previousSamples: Set<TraceGestureRecognizer.TouchSample>, with event: UIEvent) {
+        super.didUpdateSamples(previousSamples: previousSamples, with: event)
+        self.previousSamples = previousSamples
+    }
+}
+
+
+typealias LineSegment = (CGPoint, CGPoint)
+
+/** Calculates a transform which transforms `startSegment` to `endSegment`.
+ There's probably a much simpler way of doing this - pulled this from an old
+ project where I stumbled through the math myself. */
+fileprivate func transformFromPinch(startingFrom startSegment: LineSegment,
+                                    endingAt endSegment: LineSegment) -> CGAffineTransform {
+    let (a, b) = startSegment
+    let (aʹ, bʹ) = endSegment
+    
+    let displacement = b - a
+    let displacementʹ = bʹ - aʹ
+    
+    let rotationAngle =
+        atan2(displacementʹ.y, displacementʹ.x)
+        - atan2(displacement.y, displacement.x)
+    let scaleFactor = displacementʹ.magnitude / displacement.magnitude
+    let initialMidpoint = 0.5 * displacement + a
+    let finalMidpoint = 0.5 * displacementʹ + aʹ
+    
+    var pivotPoint: CGPoint? {
+        let u_ad = (bʹ.y - aʹ.y) * (b.x - a.x) - (bʹ.x - aʹ.x) * (b.y - a.y)
+        
+        guard u_ad != 0 else {
+            // parallel
+            return nil
+        }
+        
+        let u_an = (bʹ.x - aʹ.x) * (a.y - aʹ.y) - (bʹ.y - aʹ.y) * (a.x - aʹ.x)
+        let u_a = u_an / u_ad
+        
+        return CGPoint(x: a.x + u_a * (b.x - a.x),
+                       y: a.y + u_a * (b.y - a.y))
+    }
+    
+    var rotationTransform: CGAffineTransform = .identity
+    
+    if let pivotPoint = pivotPoint {
+        rotationTransform = rotationTransform
+            .concatenating(CGAffineTransform(translationX: -pivotPoint.x, y: -pivotPoint.y))
+            .concatenating(CGAffineTransform(rotationAngle: rotationAngle))
+            .concatenating(CGAffineTransform(translationX: pivotPoint.x, y: pivotPoint.y))
+    }
+    
+    let rotatedMidpoint =
+        initialMidpoint.applying(rotationTransform)
+    
+    let scaleOffset1 =
+        CGAffineTransform(translationX: -rotatedMidpoint.x,
+                          y: -rotatedMidpoint.y)
+    let scaleXform =
+        CGAffineTransform(scaleX: scaleFactor,
+                          y: scaleFactor)
+    let scaleOffset2 =
+        CGAffineTransform(translationX: finalMidpoint.x,
+                          y: finalMidpoint.y)
+    
+    let scaleTransform = CGAffineTransform.identity
+        .concatenating(scaleOffset1)
+        .concatenating(scaleXform)
+        .concatenating(scaleOffset2)
+    
+    return CGAffineTransform.identity
+        .concatenating(rotationTransform)
+        .concatenating(scaleTransform)
+}
+
+extension Sequence {
+    /**
+     Performs a SQL-like join between two sequences. This will drop ambiguous
+     rows (see example for `"NYC"` key), and will drop rows that do not have a
+     "match" (see example for `"St. Louis"` key).
+     
+     ```swift
+     let students = [
+       [name: "David", hometown: "Cranston"],
+       [name: "Stephen", hometown: "St. Louis"],
+       [name: "Erin", hometown: "NYC"],
+     ]
+     let teachers = [
+       [name: "Mo", hometown: "NYC"],
+       [name: "Brett", hometown: "San Francisco"],
+       [name: "Kathy", hometown: "Cranston"],
+       [name: "Suzanne", hometown: "NYC"],
+     ]
+     students.joined(with: teachers, on: { $0["hometown"] }).mapValues { ($0.0["name"], $0.1["name"] }
+     // => [
+     //   "Cranston": ("David", "Kathy"),
+     //   "NYC": ("Erin", "Suzanne"),
+     // ]
+     
+     let a = [1, 2, 3, 4]
+     let b = [4, 5]
+     
+     a.joined(with: b, on: { $0 % 2 })
+     // => [0: (4, 4), 1: (3, 5)]
+     ```
+     */
+    func joined<S: Sequence, JoinKey: Hashable>(with other: S, on joinAxis: (Element) -> JoinKey) -> [JoinKey: (Element, Element)] where S.Element == Element {
+        var keyed: [JoinKey: Element] = [:]
+        for item in self {
+            keyed[joinAxis(item)] = item
+        }
+        
+        var out: [JoinKey: (Element, Element)] = [:]
+        for item in other {
+            let joinKey = joinAxis(item)
+            if let fromSelf = keyed[joinKey] {
+                out[joinKey] = (fromSelf, item)
+            }
+        }
+        
+        return out
+    }
+    
+}
+
diff --git a/ios/Handlers/RNTransformGestureHandler.h b/ios/Handlers/RNTransformGestureHandler.h
new file mode 100644
index 0000000..db30cf4
--- /dev/null
+++ b/ios/Handlers/RNTransformGestureHandler.h
@@ -0,0 +1,9 @@
+#ifndef RNTransformGestureHandler_h
+#define RNTransformGestureHandler_h
+
+#import "RNGestureHandler.h"
+
+@interface RNTransformGestureHandler : RNGestureHandler
+@end
+
+#endif /* RNTransformGestureHandler_h */
diff --git a/ios/Handlers/RNTransformGestureHandler.m b/ios/Handlers/RNTransformGestureHandler.m
new file mode 100644
index 0000000..72c24d4
--- /dev/null
+++ b/ios/Handlers/RNTransformGestureHandler.m
@@ -0,0 +1,68 @@
+#import "RNTransformGestureHandler.h"
+#import "RNGestureHandler-Swift.h"
+#import <React/RCTConvert.h>
+
+@implementation RNTransformGestureHandler {
+    CGAffineTransform accumulatedTransform;
+    CGFloat maxYTranslation;
+    bool didSetInitialTransform;
+}
+
+- (instancetype)initWithTag:(NSNumber *)tag
+{
+  if ((self = [super initWithTag:tag])) {
+      _recognizer = [[NaturalTransformGestureRecognizer alloc] initWithTarget:self action:@selector(handleGesture:)];
+      accumulatedTransform = CGAffineTransformIdentity;
+      maxYTranslation = CGFLOAT_MAX;
+      didSetInitialTransform = false;
+  }
+  return self;
+}
+
+- (void)handleGesture:(NaturalTransformGestureRecognizer *)recognizer {
+    [super handleGesture:recognizer];
+    
+    CGAffineTransform nextAccumulatedTransform =
+        CGAffineTransformConcat(accumulatedTransform,
+                                recognizer.transformFromLastChange);
+    
+    if (nextAccumulatedTransform.ty > maxYTranslation) {
+        nextAccumulatedTransform.ty = maxYTranslation;
+    }
+    accumulatedTransform = nextAccumulatedTransform;
+}
+
+- (void)configure:(NSDictionary *)config
+{
+    [super configure:config];
+    id prop = config[@"initialTransform"];
+    if (prop != nil && !didSetInitialTransform) {
+        accumulatedTransform = [RCTConvert CGAffineTransform:prop];
+        didSetInitialTransform = true;
+    }
+    
+    prop = config[@"maxYTranslation"];
+    if (prop != nil) {
+        maxYTranslation = [RCTConvert CGFloat:prop];
+    }
+}
+
+- (RNGestureHandlerEventExtraData *)eventExtraData:(NaturalTransformGestureRecognizer *)recognizer{
+    return [[RNGestureHandlerEventExtraData alloc] initWithData:@{
+        @"transform": self.accumulatedTransformAsDictionary
+    }];
+}
+
+- (NSDictionary *)accumulatedTransformAsDictionary {
+    CGAffineTransform xf = accumulatedTransform;
+    return @{
+        @"a": [NSNumber numberWithDouble:xf.a],
+        @"b": [NSNumber numberWithDouble:xf.b],
+        @"c": [NSNumber numberWithDouble:xf.c],
+        @"d": [NSNumber numberWithDouble:xf.d],
+        @"tx": [NSNumber numberWithDouble:xf.tx],
+        @"ty": [NSNumber numberWithDouble:xf.ty],
+    };
+}
+
+@end
diff --git a/ios/RNGestureHandlerManager.m b/ios/RNGestureHandlerManager.m
index 517c9b9..0de843b 100644
--- a/ios/RNGestureHandlerManager.m
+++ b/ios/RNGestureHandlerManager.m
@@ -27,6 +27,7 @@
 #import "Handlers/RNPinchHandler.h"
 #import "Handlers/RNRotationHandler.h"
 #import "Handlers/RNForceTouchHandler.h"
+#import "Handlers/RNTransformGestureHandler.h"
 
 // We use the method below instead of RCTLog because we log out messages after the bridge gets
 // turned down in some cases. Which normally with RCTLog would cause a crash in DEBUG mode
@@ -64,6 +65,7 @@ - (void)createGestureHandler:(NSString *)handlerName
     static dispatch_once_t mapToken;
     dispatch_once(&mapToken, ^{
         map = @{
+                @"TransformGestureHandler" : [RNTransformGestureHandler class],
                 @"PanGestureHandler" : [RNPanGestureHandler class],
                 @"TapGestureHandler" : [RNTapGestureHandler class],
                 @"FlingGestureHandler" : [RNFlingGestureHandler class],
diff --git a/lib/typescript/handlers/gestureHandlers.d.ts b/lib/typescript/handlers/gestureHandlers.d.ts
index 0ad6d92..1a3329a 100644
--- a/lib/typescript/handlers/gestureHandlers.d.ts
+++ b/lib/typescript/handlers/gestureHandlers.d.ts
@@ -155,4 +155,15 @@ export interface RotationGestureHandlerProps extends BaseGestureHandlerProps<Rot
 }
 export declare type RotationGestureHandler = typeof RotationGestureHandler;
 export declare const RotationGestureHandler: React.ComponentType<RotationGestureHandlerProps & React.RefAttributes<any>>;
+
+export declare type TransformGestureHandlerEventPayload = {
+  x: number;
+  y: number;
+};
+export interface TransformGestureHandlerProps extends BaseGestureHandlerProps<TransformGestureHandlerEventPayload> {
+}
+
+export declare type TransformGestureHandler = typeof TransformGestureHandler;
+export declare const TransformGestureHandler: React.ComponentType<TransformGestureHandlerProps & React.RefAttributes<any>>;
+
 export {};
diff --git a/lib/typescript/index.d.ts b/lib/typescript/index.d.ts
index 0d337d0..e4ec24a 100644
--- a/lib/typescript/index.d.ts
+++ b/lib/typescript/index.d.ts
@@ -2,8 +2,8 @@ export { Directions } from './Directions';
 export { State } from './State';
 export { default as gestureHandlerRootHOC } from './gestureHandlerRootHOC';
 export { default as GestureHandlerRootView } from './GestureHandlerRootView';
-export type { GestureEvent, HandlerStateChangeEvent, GestureEventPayload, HandlerStateChangeEventPayload, TapGestureHandlerEventPayload, ForceTouchGestureHandlerEventPayload, LongPressGestureHandlerEventPayload, PanGestureHandlerEventPayload, PinchGestureHandlerEventPayload, RotationGestureHandlerEventPayload, FlingGestureHandlerEventPayload, TapGestureHandlerProps, ForceTouchGestureHandlerProps, LongPressGestureHandlerProps, PanGestureHandlerProps, PinchGestureHandlerProps, RotationGestureHandlerProps, FlingGestureHandlerProps, } from './handlers/gestureHandlers';
-export { TapGestureHandler, ForceTouchGestureHandler, LongPressGestureHandler, PanGestureHandler, PinchGestureHandler, RotationGestureHandler, FlingGestureHandler, } from './handlers/gestureHandlers';
+export type { GestureEvent, HandlerStateChangeEvent, GestureEventPayload, HandlerStateChangeEventPayload, TapGestureHandlerEventPayload, ForceTouchGestureHandlerEventPayload, LongPressGestureHandlerEventPayload, PanGestureHandlerEventPayload, PinchGestureHandlerEventPayload, RotationGestureHandlerEventPayload, FlingGestureHandlerEventPayload, TransformGestureHandlerEventPayload, TapGestureHandlerProps, ForceTouchGestureHandlerProps, LongPressGestureHandlerProps, PanGestureHandlerProps, PinchGestureHandlerProps, RotationGestureHandlerProps, FlingGestureHandlerProps, TransformGestureHandlerProps } from './handlers/gestureHandlers';
+export { TapGestureHandler, ForceTouchGestureHandler, LongPressGestureHandler, PanGestureHandler, PinchGestureHandler, RotationGestureHandler, FlingGestureHandler, TransformGestureHandler } from './handlers/gestureHandlers';
 export { default as createNativeWrapper } from './handlers/createNativeWrapper';
 export type { NativeViewGestureHandlerPayload, NativeViewGestureHandlerProps, } from './handlers/NativeViewGestureHandler';
 export { NativeViewGestureHandler } from './handlers/NativeViewGestureHandler';
diff --git a/src/handlers/gestureHandlers.ts b/src/handlers/gestureHandlers.ts
index d2be2b4..a82d607 100644
--- a/src/handlers/gestureHandlers.ts
+++ b/src/handlers/gestureHandlers.ts
@@ -509,3 +509,41 @@ export const RotationGestureHandler = createHandler<
   allowedProps: baseProps,
   config: {},
 });
+
+export type TransformGestureHandlerEventPayload = {
+  transform: {
+    a: number;
+    b: number;
+    c: number;
+    d: number;
+    tx: number;
+    ty: number;
+  };
+};
+
+export interface TransformGestureHandlerProps
+  extends BaseGestureHandlerProps<TransformGestureHandlerEventPayload> {
+    initialTransform?: {
+      a: number;
+      b: number;
+      c: number;
+      d: number;
+      tx: number;
+      ty: number;
+    };
+    maxYTranslation?: number;
+}
+
+export type TransformGestureHandler = typeof TransformGestureHandler;
+export const TransformGestureHandler = createHandler<
+  TransformGestureHandlerProps,
+  TransformGestureHandlerEventPayload
+>({
+  name: 'TransformGestureHandler',
+  allowedProps: [
+    ...baseProps,
+    'initialTransform',
+    'maxYTranslation',
+  ] as const,
+  config: {},
+});
diff --git a/src/index.ts b/src/index.ts
index 4fb626d..de3958f 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -16,6 +16,7 @@ export type {
   PinchGestureHandlerEventPayload,
   RotationGestureHandlerEventPayload,
   FlingGestureHandlerEventPayload,
+  TransformGestureHandlerEventPayload,
   // gesture handlers props types
   TapGestureHandlerProps,
   ForceTouchGestureHandlerProps,
@@ -24,6 +25,7 @@ export type {
   PinchGestureHandlerProps,
   RotationGestureHandlerProps,
   FlingGestureHandlerProps,
+  TransformGestureHandlerProps,
 } from './handlers/gestureHandlers';
 export {
   TapGestureHandler,
@@ -33,6 +35,7 @@ export {
   PinchGestureHandler,
   RotationGestureHandler,
   FlingGestureHandler,
+  TransformGestureHandler,
 } from './handlers/gestureHandlers';
 export { default as createNativeWrapper } from './handlers/createNativeWrapper';
 export type {
